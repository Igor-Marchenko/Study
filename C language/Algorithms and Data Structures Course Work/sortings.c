#include "sortings.h" //Підключаємо заголовочний файл модуля сортування (sortings) для доступу до функцій даного модуля (функції сортування матриці і сортування вектора вставкою,вибором,обміном)
#include "common.h" //Підключаємо заголовочний файл модуля коммон (common) для доступу до спільних даних окремих модулів, що знаходяться в цьому модулі (матриці, вектора, змінних)


clock_t insertion_sort() //Функція типу clock_t сортування матриці методом вставки алгоритмом №1, повертає час роботи алгоритму сортування 
{
	int x,y,x1,y1,B; //змінні x,y,x1,y1 типу int використовуються для запам'ятовування індексів;B типу int - як буферна комірка
	clock_t time_start, time_stop; //змінні типу clock_t для фіксації початку і кінця роботи алгоритму сортування
	
	time_start = clock(); //початок відліку
	
	for(k=0;k<p;k++)
	{ 	
		for(i=0;i<m;i++)
		{
			for(j=0;j<n;j++)
			{
				B=matr[k][i][j]; //запам'ятовуємо поточний елемент
				x=y=0; //початкові установки для змінних
				while(matr[k][x][y]<B) //цикл пошуку місця вставки
				{
					y=y+1; //інкрементуємо у - номер стовпчика
					if(y==n) //перевірка на вихід за матрицю
					{
						y=0; // обнуляємо у - номер стовпчика
						x=x+1; //інкрементуємо х - номер рядка
					}
				}
				x1=i;y1=j-1; //записуємо в змінні х1 та у1 значення і та j-1 - початкові установки для циклічного зсуву
				while(x1>=x) //циклічний зсув елементів матриці на одну позицію вправо
				{
					if((x1==x)&&(y1==(y-1))) //перевірка на необхідність зсуву
					{
						break;
					}
					else
					{
						if(y1==(n-1)) //перевіряємо на кінець рядка
						{
							matr[k][x1+1][0]=matr[k][x1][y1]; //зсуваємо елементи
						}
						else
						{
							matr[k][x1][y1+1]=matr[k][x1][y1]; //зсуваємо елементи
						}
					}
					
						y1=y1-1;//декрементуємо у1 - номер стовпчика
						if(y1<0) //перевірка на вихід за початок рядка
						{
							y1=n-1; //присвоюємо у1 індекс останнього стовпчика
							x1=x1-1; //зменшуємо x1 - номер рядка
						}
				}
				matr[k][x][y]=B; //вставляємо на знайдену звільнену позицію поточний елемент (взятий)
			}
		}
	}
	
	time_stop = clock(); //кінець відліку

	return time_stop - time_start; //повернення результату виміру
}

clock_t insertion_vect() //Функція типу clock_t сортування вектора методом вставки алгоритмом №1, повертає час роботи алгоритму сортування  
{
	clock_t time_start, time_stop; //змінні типу clock_t для фіксації початку і кінця роботи алгоритму сортування
	int B;//змінна В типу int - буферна змінна
	
	time_start = clock(); //початок відліку
	
	for(i=1;i<n1;i++)
	{
		B=vect[i];//запам'ятовуємо поточний елемент
		j=0; //початкові установки для змінної
		while(vect[j]<B) //цикл пошуку місця вставки
		{
			j=j+1; //інкрементуємо j 
		}
		for(k=i-1;k>=j;k--) //циклічний зсув елементів вектора на одну позицію вправо
		{
			vect[k+1]=vect[k];
		}
		vect[j]=B; //вставляємо на знайдену звільнену позицію поточний елемент (взятий)	
	}
	
	time_stop = clock(); //кінець відліку
	
	return time_stop - time_start; //повернення результату виміру
}

clock_t selection_sort() //Функція типу clock_t сортування матриці методом вибору алгоритмом №1, повертає час роботи алгоритму сортування 
{
	int x,y,z1,line,col,min;//змінні line,col,z1 типу int - параметри циклів, x,y типу int - для запам'ятовування позиції мінімального елемента;min типу int - для запам'ятовування мінімального елемента
	clock_t time_start, time_stop;//змінні типу clock_t для фіксації початку і кінця роботи алгоритму сортування
	
	time_start = clock(); //початок відліку
	
	for(k=0;k<p;k++)
	{
		for(i=0;i<m;i++)
		{
			if(i==m-1) //перевірка на необхідність встановлення межі сортування
			{
				z1=n-1;
			}
			else
			{
				z1=n;
			}
			for(j=0;j<z1;j++)
			{
				//початкові установки для пошуку мінімального елемента
				min=matr[k][i][j];
				x=i;y=j;col=j+1;line=i;
				while(line<m)
				{
					if(min>matr[k][line][col])
					{
						min=matr[k][line][col];//запам'ятовуємо мінімальний елемент
						//запам'ятовуємо його позицію
						x=line;
						y=col;
					}
					col=col+1;//збільшуємо змінну для проходу далі
					if(col>n-1)//перевірка на вихід за матрицю
					{
						col=0;//обнуляємо одну змінну - номер стовпчика
						line=line+1;//іншу - інкрементуємо - номер рядка
					}
					
				}
				//міняємо місцями мінімальний і поточний елементи
				matr[k][x][y]=matr[k][i][j];
				matr[k][i][j]=min;	
			}
		}
	}
	
	time_stop = clock(); //кінець відліку
	
	return time_stop - time_start; //повернення результату виміру
}

clock_t selection_vect() //Функція типу clock_t сортування вектора методом вибору алгоритмом №1, повертає час роботи алгоритму сортування 
{
	int min; //змінна min типу int - для запам'ятовування мінімального елемента
	clock_t time_start, time_stop;//змінні типу clock_t для фіксації початку і кінця роботи алгоритму сортування
	
	time_start = clock(); //початок відліку
	
	for(i=0;i<n1-1;i++)
	{
		min=vect[i]; k=i; //початкові установки для пошуку мінімального елемента
		for(j=i+1;j<n1;j++)
		{
			if(vect[j]<min)
			{
				min=vect[j];//запам'ятовуємо мінімальний елемент
				k=j;//запамятовуємо його позицію
			}
		}
		//міняємо місцями мінімальний і поточний елементи
		vect[k]=vect[i];
		vect[i]=min;
	}
	
	time_stop = clock(); //кінець відліку
	
	return time_stop - time_start; //повернення результату виміру
}

clock_t exchange_flag_sort() //Функція типу clock_t сортування матриці методом обміну алгоритмом №2 з прапорцем, повертає час роботи алгоритму сортування 
{
	int x,y,A,z; //змінні x,y,z типу int - межі сортування, змінна А типу int - буферна змінна
	bool flag; //прапорець типу bool
	clock_t time_start, time_stop;//змінні типу clock_t для фіксації початку і кінця роботи алгоритму сортування
	
	time_start = clock(); //початок відліку
	
	for(k=0;k<p;k++)
	{
		flag=true;//прапорець типу bool - має значення true для входження в цикл сортування
		x=m-1;z=n-2; //початкові установки межі сортування
		while(flag==true)//Цикл сортування, який продовжується доти, доки прапорець матиме значення true
		{
			flag=false; //змінюємо значення прапорця для коректної роботи алгоритму
			for(i=0;i<=x;i++)
			{
				if(i==x)//перевірка на необхідність встановлення межі сортування
				{
					y=z;
				}
				else
				{
					y=n-1;
				}
				for(j=0;j<=y;j++)
				{
					if(j==n-1)//перевірка на останній стовпчик рядка
					{
						if(matr[k][i][j]>matr[k][i+1][0])
						{
							A=matr[k][i][j];//записуємо у змінну А поточний елемент
							matr[k][i][j]=matr[k][i+1][0];//йому присвоюємо значення сусіднього елемента
							matr[k][i+1][0]=A;//сусідньому елементу присвоюємо значення елемента зі змінної А
							flag=true;//якщо перестановки були, то прапорець має значення true
						}
					}
					else
					{
						if(matr[k][i][j]>matr[k][i][j+1])
						{
							A=matr[k][i][j];//записуємо у змінну А поточний елемент
							matr[k][i][j]=matr[k][i][j+1];//йому присвоюємо значення сусіднього елемента
							matr[k][i][j+1]=A;//сусідньому елементу присвоюємо значення елемента зі змінної А
							flag=true;//якщо перестановки були, то прапорець має значення true
						}
					}
				}
			}
			z=z-1;//зменшуємо границю, бо відсортовані елементи з'являються з кінця
			if(z<0) //перевірка на вихід за початок рядка
			{
				z=n-1; //тоді z присвоюємо номер останнього стовпчика
				x=x-1; //і зменшуємо x
			}
		}
	}
	
	time_stop = clock(); //кінець відліку
	
	return time_stop - time_start; //повернення результату виміру
}

clock_t exchange_flag_vect() //Функція типу clock_t сортування вектора методом обміну алгоритмом №2 з прапорцем, повертає час роботи алгоритму сортування 
{
	int z=n1-2,A; //змінна z типу int використовується як межа сортування; А типу int - як буферна змінна
	bool flag=true; //прапорець типу bool - має значення true для входження в цикл сортування
	clock_t time_start, time_stop;//змінні типу clock_t для фіксації початку і кінця роботи алгоритму сортування
	
	time_start = clock(); //початок відліку
	
	while(flag==true) //Цикл сортування, який продовжується доти, доки прапорець матиме значення true
	{
		flag=false; //змінюємо значення прапорця для коректної роботи алгоритму
		for(i=0;i<=z;i++)
		{
			if(vect[i]>vect[i+1])//перевірка необхідності перестановки
			{
				A=vect[i]; //записуємо у змінну А поточний елемент
				vect[i]=vect[i+1]; //йому присвоюємо значення сусіднього елемента
				vect[i+1]=A; //сусідньому елементу присвоюємо значення елемента зі змінної А
				flag=true;//якщо перестановки були, то прапорець має значення true
			}
		}
		z=z-1; //зменшуємо границю, бо відсортовані елементи з'являються з кінця
	}
	
	time_stop = clock(); //кінець відліку
	
	return time_stop - time_start; //повернення результату виміру
}








